Small is Beautiful
Each Program Does One Thing Well
Prototype as Soon as Possible
Choose Portability Over Efficiency
Store Data in Flat Text Files
Use Software Leverage
Use Shell Scripts to Increase Leverage and Portability
Avoid Captive User Interface
Make Every Program a Filter

1994年，X窗口系统开发组的成员Mike Gancarz根据他自己的Unix系统经验以及和其他领域使用Unix系统的资深程序员们的讨论结果，写成了The UNIX Philosophy，提出了9条训格之言：
一：小即是美。
二：让程序只做好一件事。
三：尽可能早地创建原型。
四：可移植性比效率更重要。
五：数据应该保存为文本文件。
六：尽可能地榨取软件的全部价值。
七：使用shell脚本来提高效率和可移植性。
八：避免使用可定制性低下的用户界面。
九：所有程序都是数据的过滤器。

每个程序做好一件事。编写新的程序完成新的功能，而不是向复杂的旧程序添加新特性
期望每个程序的输出是另一个程序的输入。不要使用无关的信息混淆输出。避免严格的列或二进制输入格式。不要坚持交互式输入。
尽可能早地设计构建软件，甚至是操作系统，理想情况下是几周内。毫不犹豫地丢弃笨拙不合时宜地部分并重建它们
使用偏爱的工具来无需技巧地（unskilled）帮助减轻编程任务，即使你不得不绕道构建工具，并期望在用完它们时丢弃它们的一部分

编写只做一件事并把它们做好的程序
编写一起工作解决问题的程序（而不是编写一个大的程序解决问题）
编写处理文本流的程序，以为它具有统一界面

尽管Unix系统引入了大量革命性的程序和技术，没有单独一个程序或idea能使它正常运转。相反，使编程的方式使它高效，一个如何使用计算机的哲学。尽管这个哲学不能以一言以蔽之，但是它的核心是一个想法，即系统的能力更多地来自于程序之间的关系，而不是程序自身。许多Unix程序独自只做非常细微的事情，但是将它们联合在一起就变成通用而有用的工具。

程序之间的关系比程序自身更重要。联合一组程序完成任务，而不是使用一个大的程序完成单一任务。

构建模块化程序
编写可读的程序
使用组合
机制和策略分离
编写简单的程序
编写小的程序
编写透明的程序
编写鲁棒的程序
如果需要，使数据复杂，而不是程序
基于用户潜在的期望认知构建程序
避免无意义的输出
编写失败时容易分析定位的程序
开发者时间比机器时间更宝贵
编写抽象程序生成代码而不是手动编写代码
在polishing之前先构建软件原型
编写灵活和开发的程序
使程序和协议可扩展

Worse is better
软件的质量（受欢迎的程度）并不随着功能的增加而提高，从实用性以及易用性来考虑，功能较少的软件反而更受到使用者和市场青睐
理查·加百烈当时是一名Lisp程序员，1989年在他的"Lisp: Good News, Bad News, How to Win Big"（Lisp：好消息，坏消息，如何赢得大）一文中提出这个概念。该文章有一段标题为"The Rise of 'Worse is Better'"（“更糟就是更好”的崛起）的章节，杰米·加文斯基在加百烈于Lucid Inc.的文件中发现它并电邮寄给朋友和大学同事，因而在1991年开始广传。
Richard P. Gabriel 提议Unix的一个关键优势是他称作“糟糕的更好”的设计哲学。在“糟糕的更好”的设计风格下，接口和实现的简单性比系统的任何其他属性都更重要，包括准确性、一致性和完整性。Gabriel主张这种设计风格拥有关键的进化优势，尽管他也怀疑一些结果的质量。

罗勃·派克在他的《Notes on Programming in C》中提到了以下格言。虽然这些规则是关于程序设计的，但作为Unix哲学丝毫不为过：
规则一：你永远不会知道你的程序会在什么地方耗费时间。程序的瓶颈常常出现在意想不到的地方，因此在你确信找到瓶颈后再动手优化代码吧。
规则二：测试代码。只有在你详细测试了代码，并且发现一部分代码耗费了绝大部分的运行时间时再对程序作速度优化。
规则三：功能全面的算法（fancy algorithm）在处理小规模问题时效率很低，这是因为算法时间效率中的常量很大，而问题往往规模很小。除非你知道你遇到的常常是复杂的情况，否则就让代码丑陋但是简单而高效吧。（即使问题规模确实很大，也首先尝试第二条规则。）
规则四：功能全面的算法比简单的算法更容易产生Bug，更难实现。尽量使用简单的算法和数据结构。
规则五：数据决定一切。如果选择的数据结构能很好的管理数据，算法部分往往不言自明。记住，数据结构，而非算法，才是编程的关键。
规则六：没有第六条规则。

道格拉斯·麦克罗伊是Unix系统上管道机制的发明者，也是Unix文化的缔造者之一。他归纳的Unix哲学如下：
程序应该只关注一个目标，并尽可能把它做好。让程序能够互相协同工作。应该让程序处理文本数据流，因为这是一个通用的接口。

更加简化的版本是：做一件事，做好它。虽然只有第三条是特指Unix系统的，但Unix开发者们常常同时强调这三个信条。

KISS原则是英语 Keep It Simple, Stupid 的首字母缩略字，是一种归纳过的经验原则。KISS 原则是指在设计当中应当注重简约的原则。总结工程专业人员在设计过程中的经验，大多数系统的设计应保持简洁和单纯，而不掺入非必要的复杂性，这样的系统运作成效会取得最优；因此简单性应该是设计中的关键目标，尽量回避免不必要的复杂性。同时这原则亦有应用在商业书信[1]、设计电脑软件、动画、工程上。

完美不是当它不能再添加时，它似乎是在它不能被进一步刮除时实现的

X的设计原则，早在最初仍在麻省理工学院的阶段（1984年）就已经成形，由鲍伯·斯凯夫勒和吉姆·杰提斯两人制订出X最早的开发、强化、改进原则，原则大体如下：

- 除非没有它就无法完成一个真正完整的应用程序，否则不用增加新的功能。
- 决定一个系统不是什么和决定它是什么同样重要。与其去适应整个世界的需要，宁可使得系统可以扩展，如此才能以持续兼容的方式来满足新增需求
- 只有完全没实例时，才会比只有一个实例来的糟。
- 如果问题没完全弄懂，最好不要去解决它
- 如果可以通过10％的工作量得到90％的预期效果，应该用更简单的办法解决。（参见：更糟就是更好）
- 尽量避免复杂性。
- 提供机制而不是策略，有关用户界面的开发实现，交给实际应用者自主。
- 之后，上述原则中的第一项原则在设计X11时被加以修改，修订成：“除非已有真正的应用程序，真的需要X为其修订、增订等支持，否则不会为X增加新功能。”X基本上一直遵循这些原则，参考实现的扩展及改进也是以此原则的角度来着手，也因为奉行上述原则，使至今的最新版X仍能与最初（1987年）发布的协议标准近乎完全兼容。