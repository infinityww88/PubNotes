## 递归
迭代是人，递归是神。
递归从最宏观上表达的程序的本质，在一个 pattern 下，每次缩小问题规模一点，在计算机的飞速运行下，最后将问题缩减到最简单的问题，即递归的终点（返回点）。
使用递归也是最容易理解找到问题解法的方法。
使用递归，无论是DP还是其他算法，关键是找到子问题(pattern)，识别什么子问题，有子问题才可以归纳

115(不同子序列)和72(编辑距离)是最好的例子

无论如何，最终的解是稍微小一点规模的问题构成更大一点点规模的问题。找子问题（pattern）的最直接办法就是强行拆分子问题，将示例问题的规模缩小最小可能的一点，例如示例问题是 s 和 t 序列，那么最小可能小一点规模的问题就是 s[1:] 和 t 或者 s 和 t[1:]，然后看如何从它们得到 s 和 t 序列的解。递归终点的基础解是显而易见的。

128(最长连续子序列)：

关键是找子问题，看如何从子问题的解构成更大的问题
使用示例中的问题，强制划分为更小的问题，或者就从最小的问题开始，
看最最小的问题如何得到解（这通常是显而易见的），然后看这个最小的子问题如何构成更大的（上一个）子问题的解，直到找到归纳模式即可
例如如果题目给出的问题是序列 [x0, x1, x2, ..., xn] 那它的子问题就是 [x1, x2, ..., xn]
或者 [x0, x1, x2, ..., x(n-1)]
一般可以直接得到最简单的子问题 [] 或 [xn] 的解，然后看 [xn] 如何得到 [x(n-1)] 的解，然后看 [x(n-1)] 如何得到 [x(n-2)] 的解，依次类推，直到找到归纳模式
如果题目给出的子问题有多个，那就对每个子问题都如此，然后考察每种子问题的组合（笛卡尔积）。
例如如果题目由两个子序列构成，那子问题就是：
```
[xn] [yn]
[xn] [y(n-1), yn]
[xn] [y(n-2), y(n-1), yn]
[xn] [y(n-3), y(n-2), y(n-1), yn]
....
[x(n-1), xn] [yn]
[x(n-1), xn] [y(n-1), yn]
[x(n-1), xn] [y(n-2), y(n-1), yn]
[x(n-1), xn] [y(n-3), y(n-2), y(n-1), yn]
....
[x(n-2), x(n-1), xn] [yn]
[x(n-2), x(n-1), xn] [y(n-1), yn]
[x(n-2), x(n-1), xn] [y(n-2), y(n-1), yn]
[x(n-2), x(n-1), xn] [y(n-3), y(n-2), y(n-1), yn]
....
```
这些子问题构成的

核心就是强行拆解给出的子问题示例

尽管有多种可能的方法找出答案，例如 DP 问题也可以使用所谓的转移方程来思考，但是问题千千万，按照尽可能统一的方法思考问题，才能解决尽可能多的问题，而不是为不同问题记忆独特的解法。统一的思维模式更重要。

## 贪心

贪心算法的本质是保持记录当前最优解，保证当前找到的最优解是优于之前找到的，因此可以直接抛弃之前的最优解。

11(水容器)

maxArea 总是记录当前找到的最优解（最大容量），初始是height最两端的情形。
容量高度由当前最小一端决定。
每次从较小的一端向另一端搜索，直到找到一个更大的元素停下，然后另一侧变成较小的一端，重复这个过程，直到两个指针相遇。
之所以不考虑抛弃掉的元素和为遍历的中间元素的组合，是因为，两个端指针只会越来越大，而容量由较小的一端决定：
1 如果未遍历的组合，另一侧比抛弃的一端元素更大，那这个组合的容量由抛弃的一端的高度决定，而这个组合的长度却小于之前的组合，因此可以抛弃
2 如果未遍历的组合，另一侧比抛弃的一端元素更小，那其高度更小，长度也更新，同样可以抛弃

所有先单调遍历一端，在遍历另一端的循环，都可以写成单一循环，每次根据条件走一步

