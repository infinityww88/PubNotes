'''
贪心算法的本质是保持记录当前最优解，保证当前找到的最优解是优于之前找到的，因此可以直接抛弃之前的最优解。
maxArea 总是记录当前找到的最优解（最大容量），初始是height最两端的情形。
容量高度由当前最小一端决定。
每次从较小的一端向另一端搜索，直到找到一个更大的元素停下，然后另一侧变成较小的一端，重复这个过程，直到两个指针相遇。
之所以不考虑抛弃掉的元素和为遍历的中间元素的组合，是因为，两个端指针只会越来越大，而容量由较小的一端决定：
1 如果未遍历的组合，另一侧比抛弃的一端元素更大，那这个组合的容量由抛弃的一端的高度决定，而这个组合的长度却小于之前的组合，因此可以抛弃
2 如果未遍历的组合，另一侧比抛弃的一端元素更小，那其高度更小，长度也更新，同样可以抛弃

所有先单调遍历一端，在遍历另一端的循环，都可以写成单一循环，每次根据条件走一步
'''
class Solution:
    def maxArea(self, height):
        maxArea = 0
        l, r = 0, len(height)-1
        while l < r:
            hl = height[l]
            hr = height[r]
            if hl < hr:
                area = hl * (r - l)
                l += 1
            else:
                area = hr * (r - l)
                r -= 1
            maxArea = max(maxArea, area)
        return maxArea

print(Solution().maxArea([1,8,6,2,5,4,8,3,7]))