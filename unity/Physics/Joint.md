Configurable Joint 的 target velocity 的单位是弧度每秒，而 HingeJoint 和 ArticulationBody 的 Revolute 关节的 target velocity 是度每秒。

ArticulationBody 关节系统比 Rigidbody-Joint 系统更精确更稳定，因为它只允许 child -> parent 这样的关节连接，降低了关节结算的复杂度，代价就是应用的场景受限了。

FixedJoint 理论上应该与将 Rigidbody 的 Collider 直接挂载到 Connected Body 上面一样。但是实际上，FixedJoint 仍然会进行解算（复制 position 和 rotation），而且在复杂的关节系统中不稳定，不能像直接将 Collider 挂载到另一个 Rigidbody 一样。FixedJoint 只能单独用于简单的固定场景。它有 Break Force 和 Break Torque，用于当关节力量超过这个阈值，关节直接断开。因此要想在复杂的关节系统中使用真正固定的效果，还是直接使用 Collider Attach。而 ArticulationBody 的 Fixed Joint 则很稳定，和直接挂载 Collider Attach 一样。

仔细观察 RB（rigidbody）的 FixedJoint，在关节受力很大的时候，两个 RB 的 anchor 并不是实时重合的，会产生一定偏离，并一直尝试回到重合位置。而 ArticulationBody 的 FixedJoint 不会如此，总是保持重合。而直接挂载 Collider 则更是严格 Fixed 的。

另外看起来，Rigidbody-Joint 和 ArticulationBody 可以相互交互。一个 Rigidbody 可以影响（推挤）另一个 ArticulationBody。刚体之间交互依靠的是 Collider 的碰撞检测，二者都使用相同的 Collider。而碰撞后的效果依赖于刚体的速度、角速度、质量，而这在二者中都用对应的属性，因此 Unity 可能直接使用各自的属性进行了碰撞检测和恢复。

例如，用 HingeJoint 创建一个跷跷板，然后在一端创建一个 1kg 的 cube Rigidbody，在另一端创建一个 10kg 的 cube ArticulationBody，就会发现 ArticulationBody，Rigidbody，Joint 可以正常交互。10kg 的 AB cube 比 1kg 的 RB cube 更重，AB 可以把 RB 弹起来更高，RB 更不容易推动 AB。

二者都使用相同的 Collider，刚体碰撞检测是基于 Collider 的。因此 Rigidbody 和 ArticulationBody 的碰撞检测都可以检测到相同的碰撞。另外 Rigidbody 和 ArticulationBody 是平行的类，具有相同的属性和方法，在解析碰撞时，要使用的速度、角速度、质量等，双方都有，因此可以视为同一体系的刚体，可以想象为在解析碰撞、解算碰撞反应时，可以将 ArticulationBody 临时转换为一个 Rigidbody，或者将 Rigidbody 临时转换为一个 ArticulationBody。这就是为什么两个物理系统可以正常相互交互的原因。

ArticulationBody 可以是 Rigidbody-Joint 并行的物理系统，Rigidbody 的属性和方法在 ArticulationBody 上都有对应体

Unity 的物理系统是比较受限的，只能在有限的条件下提供“真实”效果：

* 只能模拟宏观低速的情况
* 物理单位只能使用米/分米、千克、秒这样的单位。千米/厘米/毫米、吨/克/毫克、毫秒/微秒 这些物理量都很难正确模拟
* 速度只能限制在米每秒这样的范围，即使像子弹这样的物理刚体，都是高速物体，都无法正常模拟，只能用射线模拟

还有重要的一点：物理系统中相互交互的物体的质量、力/力矩与质量的差距不能太大，要尽可能接近，这样才能得到最稳定的效果。例如一个用 Fixed Joint 固定的 1kg 的平板，从上方掉落 1kg-10kg 左右的 cube，能比较真实地模拟。但是如果 cube 的质量为 1000kg，cube 就会直接隧穿平板，这就是物理量相差太大时，无法正确模拟的情况。同样还有，当 1kg 左右的 rigidbody 在连接的关节中受力过大，例如收到 10000N 的力，也会产生不稳定模拟。要产生稳定的模拟，1kg 左右的 rigidbody 不应该承受超过 100N 的力 或 100N\*M 的力矩。这也是上面说的 Fixed 关节有时不稳定的原因，根本原因还是受到的力或力矩太大（1kg 的 rb 收到 1000N 的力诸如此类）。ArticulationBody 能较为真实地模拟 Fixed 关节，是因为它在内部会自动缩放 AB 的质量，使得关节双方的质量差距不会太大，也不会使 AB 受到太大的力或力矩，因此能产生稳定模拟。Joint 为了弥补这个问题，提供 Mass Scale 和 Connected Mass Scale，它在关节解算时，会将 AB 的质量乘以这个因子，对质量进行缩放，用于将两个 AB 的质量差距尽可能缩小，以产生稳定模拟。但是这样会使关节解算违反能量守恒定律，但是能显著提升视觉效果的稳定性和合理性。

因此物理引擎是十分娇贵的系统，不能随心所欲地使用，设计物理系统时，目标不是完全匹配现实，而是为游戏提供稳定的模拟效果，因此也不必完全遵循现实世界的物理量。例如一辆车的 body 和 wheel 的质量比不一定需要跟现实世界一样。现实世界中一个 1kg 的刚体通过关节连接一个 1000kg 的刚体，在物理引擎中，可能将其建模为 10kg 和 50kg 的两个刚体。只要视觉效果看起来对就行。不需要按照现实世界建模，因此可以直接使用默认 rb 的 1kg 作为参考基准，其他刚体、关节的参数（spring，damper，force）等等根据视觉效果试错调整来设置，不可能通过计算来设置，只要达成稳定、满足预期的效果即可。

不用期待用 Unity 物理引擎完完全全地模拟现实。物理引擎的目的就和其他系统（例如渲染、特效）一样，只是为了给玩家提供看起来“真实”的效果，而实际不一定与现实一样真实。物理引擎还是为游戏玩法提供支持，而不是为了完全模拟现实世界。

ArticulationBody 的 Prismatic 和 Configurable Joint 实现的类似关节的区别：

* Configurable Joint 的 Linear Motion 为 free 时，rb 是完全自由移动的，无论如何设置 Limit 和 Limit Spring，都没有作用，没有弹簧力。只有将 Motion 设置为 Limited，Limit 和 Limit Spring 才起作用。当 Motion 设置为 Limited，必须为 Limit 设置为一个正数范围值，rb 超出 limit 边缘时才会有弹簧效果，limit 才成为软边界。如果 limit 设置为 0，rb 的活动范围将完全静止。即使设置 spring 无论任何数值，rb 也不会移动，就像 fixed。如果 limit 设置为整数范围，而 spring 设置为 0，则没有弹簧力，则 limit 范围将成为硬边界，rb 从不会超出。
* Prismatic Motion 设置为 Free 时，只有 stiffness（spring）为 0 时，ab 才能自由没有限制地移动，当 stiffness > 0 时，就会有弹簧效果，弹簧中和点由 target 定义。当 Motion 设置为 Limited 时，出现 Lower Limit 和 Upper Limit，它们是 Prismatic Motion 的硬边界，ab 从不会超出这个范围。如果 Lower Limit 和 Upper Limit 都为 0，则 ab 被完全固定，如同 fixed。target 仍然是沿着 anchor axis 定义的偏移，Lower Limit 和 Upper Limit 也是沿着 anchor axis 定义的范围，Limit 并不是在 target 两端定义的范围，而是在 anchor 两端定义的范围，target 可以在 limit 范围之内，可以在 limit 的范围之外，但无论如何 target 定义了弹簧中和点，Lower Limit 和 Upper Limit 定义了范围的硬边界。ab 的运动硬性限制在 limit 的范围内，但是在 target 周围弹性运动。

# 如何使用物理引擎

要认识到，物理引擎不是为了让你模拟真实世界的物理规律（牛顿运动定律），然后通过计算机模拟研究自然现象（这些是计算机模拟领域的工作）。更多的时候是为了创作让人信服的可视化“世界”，一切为了体验、为了渲染，让玩家感受到仿佛在真实的世界中。这与 NavMesh、各种视觉欺骗的渲染技术（例如 LOD，多个 quad 渲染草丛、树叶）、网络引擎（Fishnet，用 Interpolation、缓存和平衡隐藏遮掩网络的延迟和抖动）一样，它们都不是为了还原真实世界的情形，而是为了“欺骗”玩家，为它们创造一个“看起来真实”的世界。即使这样，每个系统仍然有自己各种各样的无法避免的问题，出现明显的瑕疵和不真实。开发者所有做的工作就是让这些瑕疵和不真实变得最小化，尽量向玩家隐藏，即使出现也不会让玩家注意到或反感，但是它们仍然无法避免。

游戏开发的一项重要工作就是“视觉欺骗”玩家。游戏世界看起来真实，但是实际里面的机制可能完全与世界的真实机制背道而驰。

物理引擎也是如此。它存在的目的是为了让你更容易、更轻松地创建符合物理规律的运动，但不是为了模拟世界。也就是说，很多物理运动你完全可以手写实现，但是手写很复杂，而且这样的功能很常见，因此物理引擎提供了很多功能，让你免去手写这些机制的需求，只需要设置几个参数就可以达到目的。这才是物理引擎的意义所在，它辅助你创建可信服的世界，但是不是让你拿它模拟自然规律。

例如：

- 匀速直线运动

  可以完全编写脚本，在 Update 中按一定速度移动 transform.position，而使用物理引擎，只需要在刚体上设置 velocity 即可。

  这是使用物理引擎最典型的粒子，利用物理引擎的机制实现你想要的效果，最小化手写代码的需求。

- 带阻尼的允许直线运动

  在 Update 中以固定速度移动 transform.position 时，还要计算如何随世界减小移动速度，直到速度足够小，物体完全停止运动。

  在物理引擎中，只需要设置一个 Linear Damping 参数即可。

- 模拟万有引力定律（行星环绕恒星运动）

  简单的环绕可以直接手写（transform.Rotate）。

  但是对于椭圆形轨道，行星在近地点加速运动，在远地点减速运动，要手写模拟这些现象就比较麻烦。

  可以用 Spline 创建要给椭圆轨道，然后再近地点和远地点都设置 custom data 用作行星在 spline 上的运动速度，这些速度会在 spline 上插值。

  可以实现，但是很麻烦。但是用物理引擎，就很容易。为恒星创建一个 Kinematic Rigidbody，或者质量很大的 Rigidbody，然后为行星的 Rigidbody 设置一个初始速度，并为行星实时施加一个朝向恒星 Rigidbody 的引力即可。行星轨道的形状只需通过调整初始速度和引力大小即可。

- 星型发动机

  星型发动机真实运动是活塞带动连杆，连杆带动飞轮。
  
  使用物理引擎模拟，完全可以不必遵循真实世界规律。让飞轮旋转（给它一个角速度驱动），让它带动连杆，然后让连杆带动活塞。这样看起来，最后的效果也是完全一样。

  甚至飞轮和活塞完全可以不连接，而是以相同的周期运动（飞轮做匀速圆周运动，活塞做线性往复运动），然后连杆通过计算匹配到飞轮和活塞的锚点上。这些都是可以的。

  总之就是，物理引擎不是为了模拟世界，而是让你用它创建可信服的世界。

对于很多复杂现象、机制，用手写太复杂，用物理引擎也无法完全实现，就可以一部分用物理引擎。物理引擎也是一套计算机制而已，跟你手写的计算机制一样。你就把它视为一套开箱可用的计算套件即可，具体怎么使用完全取决于你。但是创造可信服的世界，不会也不可能完全通过一个系统（NavMesh、物理、网络）就能完成的，它们只是减少人工工作的机制，还需要你通过各种“取巧”、“整合”加上手写一定的代码、调整参数，才能达成。

例如复杂的系统，需要物理关节、动画、手工代码共同才能完成。

推而广之，所有下的游戏开发工具都是开箱即用的工具，用来辅助你创建可信服的游戏世界，怎么使用完全取决于你，没有一定之规。但是要最大最好发挥它们的能力，你必须了解的它们的原理、限制，知道怎么用最好，不应该怎么用。

例如渲染 shader 的透明机制，不能处理真实世界中的任意透明现象，需要考虑物体的前后远近、shader 的 queue order 等等。但是它确实提供了透明的机制，让你用这些工具来解决游戏世界的透明渲染问题。

简而言之，使用用物理引擎的原则是，你想要创造一个让人信服的物理现象，然后使用物理引擎提供的各种开箱即用的工具帮助你完成这项工作，而不是用物理引擎为真实世界建模。物理引擎创建的物理世界的模型可能与真实世界大相径庭。

不要按照你的游戏世界在物理引擎中建模，不一定把真实世界的刚体视为物理引擎中的刚体，把真实世界的的关节视为物理引擎中的关节。

```
早期《魔兽世界》中，为了实现特定的游戏机制，如BOSS战技能及多样化的任务追踪，开发人员巧妙利用隐形兔子来达成目标。 这些隐形兔子在BOSS战中充当目标，在任务系统中则帮助记录任务进度。 无论是复杂精妙的 BOSS 战，还是丰富多样的任务系统，《魔兽世界》都让当时的玩家大开眼界，但《魔兽世界》里有不少新颖的游戏机制，都建立在一个出人意料的东西上面——那就是兔子。 还是看不见、点不了的隐形兔子。
```

不要相信游戏开发工具能为真实世界建模，创建一个各个细节都完美匹配真实世界的虚幻世界。游戏设计与开发是“欺骗”、“权衡取舍”、“凑合”的艺术，用各种乱七八糟的工具、机制，创建一个让玩家信服的世界。外面看着光鲜、里面乱七八糟混乱一片才是常态。

# 最小化关节使用

要用最保守的态度使用关节。

## FixedJoint

**FixedJoint 链接的两个 Rigidbody** vs **直接把 Collider 挂在同一个 Rigidbody 下**，即使忽略质量、质心和关节约束，

```
FixedJoint 连接两个 Rigidbody 和 单个 Rigidbody 上多个 Collider 在**物理交互层面仍然不同**。
```

> **前者是两个独立刚体，PhysX 在解算时要处理接触约束；**
> **后者是一个复合刚体（compound shape），外界看到的始终是单一刚体形状。**

### 详细对比

| 项目                                 | **多个 Collider 组成一个 Rigidbody**      | **用 FixedJoint 连接两个 Rigidbody**   |
| ---------------------------------- | ----------------------------------- | --------------------------------- |
| **物理实体数量**                         | 1 个刚体（一个物理 body）                    | 2 个刚体（两个独立 body）                  |
| **物理求解方式**                         | 外部物体与整个复合体一次碰撞解算                    | 外部物体与两刚体分别发生碰撞，之后用 joint 约束同步它们   |
| **碰撞检测阶段（Broadphase/Narrowphase）** | 所有 Collider 被视为同一个体（Compound Shape） | 每个 Rigidbody 各有自己的碰撞体             |
| **接触求解（Contact Solve）**            | 单刚体的接触力直接整合                         | 两刚体各自产生接触反力，joint 再传递这些力以维持“固定关系” |
| **稳定性**                            | 非常稳定（无内部力）                          | 略有误差与抖动，取决于 joint 解算精度            |
| **性能**                             | 更高效：1 个刚体 + 多个 Collider             | 稍差：2 个刚体 + 1 个 joint（增加求解约束）      |
| **惯性行为**                           | 统一的质心与惯性张量                          | 各自独立，joint 负责力传递（增加数值复杂度）         |
| **外界看到的“碰撞体”**                     | 看似一个整体（不可分割）                        | 实际是两个刚体被约束成“看似”一体                 |

###  物理层面解释（PhysX 内部视角）

#### **单刚体 + 多 Collider**

* Unity 在导出物理世界时，会创建一个 `PxRigidDynamic`（或 `PxRigidStatic`）；
* 所有子 Collider 都被注册为该刚体的 **compound shape**；
* 碰撞检测只需一次求解，计算更快更稳定；
* 接触反力只施加在这一个刚体上；
* 不存在内部“约束”力。

> 从物理上，这是真正的一个整体物体。

#### **两个 Rigidbody + FixedJoint**

* Unity 创建两个 `PxRigidDynamic`；
* 外界物体分别可能与两者发生接触；
* FixedJoint 在每帧解算时插入约束：

  “保持相对位置和旋转不变”。

* 当碰撞发生时：

  * 每个刚体各自受外力；
  * joint 再施加反向力使它们保持相对固定；
  * 导致内部力传递与数值误差；
  * 可能出现微小抖动或 joint stress（尤其在高质量比或高速度时）。

>  从物理上，这是两个独立刚体被“绑定”成一个整体，但依然存在内部解算过程。

### 即使忽略质量与断裂

也仍然存在：

1. **求解顺序差异**：
   FixedJoint 连接体要在碰撞解算后再执行 joint 约束解算；
2. **接触冗余**：
   两个 Rigidbody 的 Collider 若与同一物体接触，可能各自产生接触点（性能浪费）；
3. **力传递方式不同**：
   单刚体：接触力直接改变整体线动量；
   两刚体 + joint：接触力先作用在一方，再经 joint 传递。

### 举个直观例子

假设你有一个木箱（Rigidbody A）和一个“钉在上面的铁块”（Rigidbody B）：

#### 情况1：铁块的 Collider 直接挂在木箱 Rigidbody 下

* 整体是一个刚体；
* 外界撞击时，木箱和铁块作为一个整体响应；
* 不会出现相对晃动或内部力；
* 性能好，稳定。

#### 情况2：铁块是独立 Rigidbody，用 FixedJoint 链接到木箱

* 看起来行为差不多；
* 但当高速撞击时：

  * 两个刚体可能会产生微小分离或内部应力；
  * Unity 会解算 joint 约束力；
  * 性能略低；
  * 可能出现轻微震荡。

### 性能对比（概念上）

| 场景               | 碰撞求解次数 | Joint 求解次数 | 总复杂度   |
| ---------------- | ------ | ---------- | ------ |
| 单刚体复合体           | 1      | 0          | O(1)   |
| 两刚体 + FixedJoint | 2      | 1          | O(2~3) |

###  结论总结

| 项目      | 单刚体 + 多 Collider | 多刚体 + FixedJoint |
| ------- | ---------------- | ---------------- |
| 与外界交互结果 | 非常一致（整体反应）       | 类似，但有微小误差        |
| 数值稳定性   | ✅ 高              | ⚠️ 略低            |
| 物理性能    | ✅ 更好             | ⚠️ 稍差            |
| 内部力计算   | ❌ 无              | ✅ 有 joint 约束力    |
| 使用场景    | 刚性整体、武器、载具外壳     | 模块化结构、可断裂部件、机械臂  |

**所以答案是：**

> 即使忽略质量和断裂因素，
> 「FixedJoint 链接两个 Rigidbody」与「合并 Collider 到同一个 Rigidbody」在物理求解机制上仍不同。
>
> **前者有两次独立碰撞 + 约束解算，后者一次整体碰撞解算。**
> 结果上看“几乎一样”，但数值稳定性与性能都会略差。

## 关节最小化原则

Unity（以及其底层 PhysX 引擎）物理系统的**核心经验法则**之一：

> **「能不用关节就不用，能用一个就别用两个；能用复合刚体就别用关节连接。」**

**关节越多越不稳定、越偏离预期**，而关节少反而更精确。

### 一、Unity 关节的本质（Joint = 约束求解器 Constraint Solver）

Unity 的关节（`FixedJoint`, `HingeJoint`, `ConfigurableJoint` 等）
在底层 PhysX 引擎中，都只是**“约束方程”（constraint equations）**。

当物理求解时，PhysX 会为每个刚体求解一组方程：

```text
力 + 碰撞约束 + 关节约束 = 0
```

每个关节会在系统中增加若干个约束（例如 6 自由度的 ConfigurableJoint 会添加多达 6 个约束方程）。
这些约束不是解析精确解，而是通过**迭代近似求解（Iterative Gauss-Seidel Solver）**完成的。

### 二、为什么关节越多越“乱”

#### **约束方程会相互干扰**

多个关节意味着多个额外的约束方程。
如果这些约束之间相互耦合（比如多个刚体互相连接成环），PhysX 的迭代求解就无法一次性满足所有约束，结果只能「大致接近」。

于是出现：

* 微小抖动；
* 相对偏移；
* 旋转漂移；
* 甚至结构爆炸（约束解发散）。

这也是为什么：

> 「机械臂」或「复杂骨骼刚体链」往往抖动严重。
> 「单个刚体 + 多 Collider」则几乎完全稳定。

#### **迭代次数有限，精度受限**

PhysX 默认每帧只进行少量（通常 6~10 次）约束求解迭代。
越多的 joint，方程越多，分配到每个 joint 的迭代次数越少 → 约束精度下降。

结果表现为：

* FixedJoint 不再完全固定（微微“拉伸”）；
* HingeJoint 出现轴线漂移；
* ConfigurableJoint 出现角度飘移；
* 大型链条“软塌塌”的。

#### **闭环结构无法完美约束**

比如你做一个立方体框架：

```
A - B
|   |
D - C
```

每条边都是 FixedJoint。
这叫**约束环（constraint loop）**，在数学上会产生过度约束（redundant constraints）。
PhysX 的迭代解法无法完美满足环形方程 → **系统内部产生张力，出现震动或爆炸。**

这就是为什么 Unity 官方在文档里建议：

> ❌ 避免形成关节闭环（joint loop）。
> ✅ 尽量使用层级树状结构（joint chain）。

#### **数值累积误差**

关节之间的相对位置与旋转每帧都会解算一点误差；
这些误差积累后，可能导致整个结构慢慢“蠕动”或“塌陷”。
尤其在低迭代、高速度或质量比例悬殊时更加明显。

### 三、性能层面也会急剧下降

| 场景                         | Joint 数量 | 每帧解算负担 | 稳定性    |
| -------------------------- | -------- | ------ | ------ |
| 单个刚体 + 多 Collider          | 0        | 极低     | ✅ 稳定   |
| 2 个刚体 + 1 FixedJoint       | 1        | 低      | ✅ 稳定   |
| 10 个刚体 + 链式 HingeJoint     | 9        | 中      | ⚠️ 有抖动 |
| 30 个刚体 + ConfigurableJoint | 29       | 高      | ❌ 极不稳定 |
| 复杂闭环结构（机械臂/车架）             | N > 10   | 很高     | ❌ 不可预测 |

### 四、专业经验总结：设计准则

| 设计目的             | 推荐结构                            | 说明      |
| ---------------- | ------------------------------- | ------- |
| 硬连接结构（武器、载具、装饰件） | ✅ 用复合 Collider 挂在同一 Rigidbody 上 | 无关节误差   |
| 铰接结构（门、轮子）       | ✅ 单一 HingeJoint                 | 保持简单    |
| 多段链条             | ⚠️ 少量 HingeJoint + 限制质量比        | 尽量少段    |
| 机械臂、复杂装配         | ⚠️ 使用 ArticulationBody          | 更精确但更贵  |
| 可破坏结构            | ✅ 用 FixedJoint，可断裂              | 关节数量有限  |
| 骨骼动画物理化（ragdoll） | ⚠️ 小规模、低关节数                     | 大规模极难稳定 |

### 五、如果必须用多个 Joint，优化建议

1. **调高 Solver Iteration**
   在 Rigidbody 或 Physics Settings 中：

   ```
   Solver Iteration Count: 6 → 12 或更多
   ```

   可以提升约束精度。

2. **控制质量比例**
   相连刚体的质量差不要超过 10 倍，否则 joint 会震荡。

3. **限制关节自由度**
   用 `ConfigurableJoint` 只启用必要的自由度，其他都锁死。

4. **避免环形连接**
   始终使用树状层级结构。

5. **降低物理步长（更小 Fixed Timestep）**
   提高解算频率。

### 六、更高阶的替代方案

| 场景        | 建议替代方案                                                  |
| --------- | ------------------------------------------------------- |
| 稳定机械链     | 使用 **ArticulationBody** 系统（Unity 2020+），支持解析求解、真正的刚性链约束 |
| 碰撞一体的静态装饰 | 使用单个 Rigidbody + 多个 Collider                            |
| 复杂可破坏物体   | 混合使用 Joint + 碰撞事件手动重建结构                                 |
| 动画驱动物理    | 使用 Animation Rigging 或 Hybrid IK                        |

### 结论总结

> 🔹 Unity 的关节越多，系统方程越复杂；
> 🔹 PhysX 是**近似解算**而非精确刚体约束；
> 🔹 因此关节多时稳定性、精度和性能都会显著下降。
>
> **少量、简洁、非闭环的关节结构 = 高稳定性 + 高性能。**

## 相同情况下，articulation body 更好

**ArticulationBody 确实比传统 Rigidbody + Joint 系统在多关节结构上更稳定、更精确、更“机械真实”**。但：

* 它也更重（计算复杂），
* 设计上偏向机器人、机械臂、载具、骨架等**树状层级结构**，
* 而不适用于任意复杂拓扑（例如环状关节、动态断裂等）。

### 深入对比：Rigidbody + Joint vs ArticulationBody

| 项目         | Rigidbody + Joint         | ArticulationBody                   |
| ---------- | ------------------------- | ---------------------------------- |
| **物理求解方式** | 离散约束迭代（Constraint Solver） | 基于树状的刚体动力学（Featherstone algorithm） |
| **关节结构支持** | 任意连接拓扑（但数值不稳定）            | 仅支持树结构（不能有环）                       |
| **数值稳定性**  | 随关节数量增加迅速恶化，易出现抖动、漂移、能量爆炸 | 高度稳定，支持几十个关节无明显误差                  |
| **性能**     | 对少量关节较快                   | 对多关节系统反而更高效（因为树求解算法）               |
| **用途典型场景** | 一般刚体交互、简单机械               | 机器人、机械臂、车辆悬挂、角色骨骼驱动等               |
| **动力学精度**  | 近似解（非严格物理）                | 精确刚体动力学解（支持扭矩驱动等）                  |
| **力与扭矩控制** | 不太精确，容易受数值误差干扰            | 可用力/扭矩精确控制各关节（理想用于控制系统）            |

### 关节多也没关系，但必须是树形

在 **Rigidbody + Joint 系统** 中，这是完全正确的经验法则：

* 每个 Joint 都是一个“约束方程”，PhysX 通过迭代求解器近似满足所有约束。
* 约束越多，收敛越困难（迭代次数固定），误差叠加导致：

  * 抖动、拉扯、松弛、能量积累、爆炸等。

而在 **ArticulationBody 系统** 中，

* 求解是解析的树结构解（一次性计算链路的整体姿态），
* 所以 **关节多也没关系**（在树状结构内）。
* 但前提是**结构必须是树形**，不能出现“两个 articulation body 交叉约束”的情况。

### 例子说明

假设你做一个机械臂：

| 结构         | Rigidbody 系统                 | ArticulationBody 系统    |
| ---------- | ---------------------------- | ---------------------- |
| 6 关节机械臂    | 很容易爆炸或抖动（需要关节限制调参）           | 高度稳定，力控制平滑             |
| 铰接车辆悬挂     | 需要大量 Joint 调参（spring/damper） | 自然稳定，可用扭矩控制悬挂力         |
| 骨骼 ragdoll | 可工作但误差大                      | 不支持非树状（人形骨架带肩锁骨连接会出问题） |

### 总结建议

| 使用场景               | 推荐方案                                        |
| ------------------ | ------------------------------------------- |
| 一般物体碰撞、破碎、推拉       | Rigidbody + Joint                           |
| 机械臂、载具悬挂、机器人仿真     | ArticulationBody                            |
| 想减少奇怪的 joint 抖动/拉伸 | 考虑改用 ArticulationBody 或减少关节数量               |
| 想做角色 ragdoll 或布偶物理 | 仍建议 Rigidbody + Joint（Articulation 不支持环形骨架） |

## 总结

1. 首先不要用物理引擎为真实世界建模，物理引擎只是为你提供了一组开箱即用的工具
2. 关节能少用就少用，不要用 FixedJoint 模拟连接在一起的刚体。只要是固定在一起运动的形状，使用 Collider 组合将它们作为一个整体刚体
3. 物理引擎只是一组计算套件，可以和手写代码、动画混合使用，解决问题即可
