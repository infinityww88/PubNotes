Be stupid
Don't be clever
Bottom up
Refactor, don't design

思考如何更优化地实现以及在各种方案中进行选择所浪费的时间和精力（进而导致的烦恼）带来的代价远远大于它们带来的收益。时间和精力要放在价值高的地方：游戏性和关键区域性能。游戏性才是最值得花时间关注的地方，而关键区域性能只存在于游戏循环中，对于 UI 相关以及类似的，只会偶尔执行的代码区域，根本不值得仔细设计和实现，不需要考虑最佳性能，只需要使用任何方法来快速实现，以现在计算机的计算能力，这些根本不可能造成问题。而且好的代码和架构不是设计出来的，而是迭代出来的，如果任何一个地方确认需要优化，也是很容易的事情，不要过早优化。对于这些地方，即使明知道有更优化的方法来实现也不要考虑，只要用最简单最直接了当的方法快速完成，考虑它们的性能优化完全是浪费时间。这就像用脚本语言编程一样，无论是代码里，还是解释器或虚拟机内部本身，相比于编译型语言，绝大多数的地方都不是最优的，都充满的冗余。但是使用的时候从来不会认为这是个问题。因为绝大多数情况下，脚本的应用场景都是不需要高性能的，相反便捷性，快速实现想法才是它追求的目标。游戏编程也是一样，其实绝大多数的地方（例如 UI ），都是不需要性能的，都只是偶尔执行的，只有游戏循环中的代码才需要考虑性能（而这只是非常少的地方）。因此，即使是游戏中，UI 这样不是频繁执行的代码即使用脚本语言实现都没问题。游戏编程要有脚本思维，牺牲性能换取便捷性。对游戏来说，迭代速度就是一切，完成比完美更重要。

对于优化，最重要的问题不是如何优化，而是确定优化的区域。因为对非必要的区域进行优化只是一厢情愿的浪费时间，通常那只是因为你知道能那么做，而不是应该那么做而已。一旦确定了目标区域，优化本身反而是容易的。

像使用脚本语言一样进行游戏开发，快速实现才是一切，在实践中确定需要优化的地方。对于脚本语言代码，确定了需要优化的地方后，这些地方会使用高性能的编译型语言来实现。

把资源（时间和技术）用在高价值的地方，对高价值的关键核心区域可以花费精心设计（例如状态机）、优化性能（例如缓存对象池），对于低价值不重要的地方简单粗略（不要在各种可能的实现之间进行评估选择）。不需要对所有的地方都精心设计，该精致的地方精致，该粗糙的地方粗糙。只有对关键核心区域的设计才是体现能力的地方，对不需要的地方如此只是没有意义的浪费时间。将有限的资源合理分配到价值不一的各个地方也是一种关键能力。

代码、系统、架构的设计不是针对机器的，而是针对人的。设计的核心是整理，就像整理房间一样，目的是当你需要找到一个东西的时候能快速找到，仅此而已。对于机器而言，如何设计是没有意义，即使完全意大利面式的代码，只要能正确运行，都没有区别。甚至通常，越是良好的设计，越需要机器做出妥协（牺牲一部分性能，包含一定程度冗余，使用不那么性能友好的方法实现，但是可以大大减轻人维护的成本负担）。各种设计模式的终极要义就是归纳整理，减少头脑负担。只要能达到这一目的，不管什么方法都是好方法。

归纳整理的本质就是为不同的 code 找合适的容器（源文件）。

UnityEvent 或 UltEvent 这些解耦工具只适合于只向外提供服务的自包含插件或模块，向外提供 event slot，例如 VisualTweenSequence。不适合用于组装应用程序逻辑，因为它们不是自包含的，而且经常改动，触及程序各个地方，在 Inspector 中不断跳转查找程序逻辑违法了上面归纳整理的原则（不能很快找到需要的东西）。对于应用程序逻辑，UnityEvent 和 UltEvent 应该尽量不包含逻辑相关的东西，比如和程序有关的参数，应该尽量使用 UnityEvent 的 void 版本。只将它作为胶水层，为应用程序创建入口，将应用程序逻辑与各种事件源或插件串联起来。它只是电路板的导线，只负责将不同的模块连接起来，不应该包含任何程序逻辑。所有程序逻辑必须在 code 中追溯。

UnityEvent 可以做为 MessageBus 使用。所有 MessageBus 的用法都是：

1. 定义一个 message
2. 接受者在 onEnable 和 OnDisable 分别注册和注销 Listener
3. 事件发起者 Invoke 事件

UnityEvent 和各种序列化事件系统本质都是将前两步自动化，免去手动定义事件和注册、注销 listener 的麻烦而已。一个 asset 就是一个事件，并且自动注册反注册。MessageDispatcher 或者 C# event/delegate 则需要显式定义事件+手动注册注销。

UnityEvent 作为 MsgBus 使用，与正统的事件系统唯一的区别是，后者每个接收者在自身内部注册 listener，而 UnityEvent 需要在定义它的地方（组件的 Inspector）中注册事件。这其实是差不多的，正统事件系统中接收者想要注册注销事件，必须要引用事件 asset 才可以。UnityEvent 中接收者虽然不需要引用事件 asset，但是将它注册到 UnityEvent 时需要找到 UnityEvent 的定义，这个过程相当于引用了 Event asset。

由于游戏作为实时计算应用程序的本质，游戏中的很多系统的更新都不是立即的，通常都带有某种缓存系统，接受新的计算请求后，会随着时间（帧数）慢慢更新，将计算量分配到多个帧中，而不是全部堆积在一帧中计算，这样对导致 frame drop。这是游戏编程的一般原则。因此不应该习惯在请求后期望立即得到结果（这通常是想要同步得到结果，进行后续计算），这不是游戏编程的范式，而是通过一些信号，进行显示同步（在异步编程中同步前后依赖的操作）。UGUI 的 Layout 更新，Physics 的 Collider 更新，Curvy 改变 ControlPoints 后 Curve 的更新无不如此。强制同一帧同步得到结果不仅违反游戏编程的一般原则，而且很多时候无法实现，例如 Physics 和 Curvy 都没有提供强制重新结算最新状态的接口。因此要习惯和遵守延迟计算，在异步中同步的原则。通常情况下，延迟 1 帧或 2 帧就足够了。这也是为什么越来越多的系统都开始提供异步编程接口 Async Task 的原因。
