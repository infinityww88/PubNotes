conditional task
public成员在bt inspector面板中显示
public shared成员在bt不同的task中共享
task不是bt附着所在Gameobject上的组件，bt是Unity的Component，task是bt中的object
但是task中也预置了gameobject，transform等Component中的变量，所以基本可以直接按Component使用
SharedTransform是bt系统提供的在不同task之间共享的变量，除了SharedTransform还有SharedFloat／SharedInt等等，但是因为task／action中都引用这当前bt所在的gameobject，因此应该也可以使用gameobject上的组件中的变量来在不同的task之间共享数据，但是根据隔离封装原则，AI的数据应该只局限在AI组件中，所以应该尽可能使用Task来保存AI数据，最好是所有AI相关的代码都在这里，而不必在gameobject中保存任何AI相关的数据，这样BT树可以在不同的gameobject上使用，否则如果使用特定组件在task之间共享数据，则bt树就不能方便的在不同的gameobject上复用
task OnUpdate返回TaskStatus
bt每次update时根据task的OnUpdate结果决策

dynamic variable不引用任何gameobject／component中的变量，只是用来在使用它的几个task之间传递数据
local variable引用某个gameobject的变量，只在当前bt中的task共享数据
global variable和local variable类似，在所有bt的task中共享数据, global variable也可以被非task派生的objects访问

Task inspector显示Task定义的可序列化变量，非shared的变量就像普通的component变量一样直接在面板上赋值，shared变量右边的圆点按钮可以切换变量赋值方式，一种是像非shared变量一样直接赋值，在task运行时变量的值就是这个值，另一种就是选择一个Variables选项页中定义的共享变量，与其他task共享变量。如果发现和其他task共享的变量没有按照预期方式赋值，很可能是在Inspector中把变量设置成直接赋值方式了

Bt树root求值完毕即结束，每个bt树只求值一次，一旦root得到求值结果就结束了
若想bt树始终运行，可以在root节点下面挂载一个until装饰task，使得其永远得不到想要的值，bt树就会一直运行下去

Component在面板中disable，Start／Update等生命周期回调函数不在调用，但是碰撞检测回调函数函数OnTriggerEnter／OnCollisionEnter似乎没有检测脚本是否被disable了，仍然能收到回调

由多个层级构成的gameobject之间的碰撞检测，回调函数只会发送给真正发生碰撞的Collider所在的gameobject，回调参数中的gameobject也是对面真正发生碰撞的gameobject，不会发送给parent及更高层，参数也不是对面的parent及更高层

Component Script可以包含在namespace中，以避免名字冲突，组件文件名仍然使用类名，这样可以在不同的命名空间中包含相同名字的组件，如Test。但是因为文件名即组件名，尽管class可以在不同的namespace中重名，但是文件系统不允许同一个目录下有重名文件，所以需要把不同命名空间的相同名字的组件脚本放在不同的目录中。

UnitEvent<T>模板参数可序列化时，在面板上可以选择static方法调用，这样的参数从面板上指定而不是使用代码中Invoke传入的值；否则，只能选择dynamic调用，参数只能在代码中Invoke调用时指定，不能在Inspector中设置

先在Vs中设定断点，点击Attach to Unity启动调试，运行Unity，就这样两边来回调

拖拽组件脚本到inspector中，unity使用脚本名字搜索程序集中相同名字的组件，例如脚本代码中定义了一个组件，但是脚本名是另一个组件的名字，当拖拽脚本到inspector中时，添加的是和脚本名同名的组件，而不是脚本中定义的组件，但是组件名必须是脚本名，否则在Unity编辑器中无法添加对应的组件，UnityEditor假设组件名是和脚本名对应的。但是可以在代码中通过AddComponent添加没有对应脚本名的组件，例如在一个文件中定义许多组件，这些组件不能通过Editor添加，但是可以在程序中动态添加。

Behavior Designer内置task不需要文档，在task面板中，右键单击task，选择edit直接进入task的代码中，无论是内置的task还是自定义的task
task自定义非常简单，只需要关注OnUpdate返回何种TaskStatus，task需要哪些变量，如何在OnStart／OnEnd／OnBehaviorTreeComplete／OnReset／OnPause初始化和析构task的各种变量即可
BD的事件系统只是简单的回调，不涉及任何和task tree相关的东西，而是接受事件的task根据自己的逻辑确定在OnUpdate中返回什么TaskStatus，除此以外没有任何额外的东西。
使用BD事件很简单，与task无关，任何需要接受事件的代码调用behaviorTree.RegisterEvent注册监听，不需要的时候behaviorTree.UnregisterEvent解除监听即可。BD内置的SendEvent和HasReceivedEvent也是如此，唯一不同的是，在task代码内部，可以通过属性Owner直接得到task所在的behaviorTree，而其他代码例如Component就需要通过其他方法得到behaviorTree（例如GetComponent<BehaviorTree>()）
在HasReceivedEvent内部，事件回调函数只是设置了一个eventReceived变量，并把时间参数保存到storedValue中而已，在OnUpdate时通过判断eventReceived变量来确定返回TaskStatus.Failure还是Success
Task生命周期函数：
OnStart／OnEnd在每次task求值开始结束时调用
OnPause在behaviorTree被调用Pause时调用
OnReset是Inspector编辑功能，在Task Inspector右上角菜单中选择Reset时被调用，确定Task的各种状态reset到什么值
OnBehaviorComplete在最终整个BT求值完成时被调用，但是如果在Behavior面板中选择RestartWhenComplete时，Restart不算Behavior Tree Complete，这个回调不会被调用，而是整个BT从头开始重新求值。这又引出另外一个问题，如何设计始终运行的tree。一种是，tree只求值一次，结束后自动restart；另一种是使用Repeater Task，并选择RepeatForever，作为tree的root节点。但是因为auto restart的tree不会调用OnBehaviorComplete，因此这两种方式没有什么区别。但是因为后面一种需要一个Repeater Task，前面一种更可取。无论如何OnStart/OnEnd在每次求值开始和结束都会调用。
调试
尽管Task面板中，运行成功的task会在右下角显示对勾或错叉，但是这只是可视化辅助，在task状态改变太快的情况下不一定准确。例如HasReceivedEvent，在收到事件后，set eventReceived变量，下一次OnUpdate会返回success，task图标本应该显示对勾，但是因为OnUpdate返回了非Running状态，求值结束，OnEnd函数被调用，reset了eventReceived变量，bt树很快被重新求值，即HasReceivedEvent很快又返回了Failure，task图标又开始显示错叉。可能是task图标显示求值状态有一个动画过渡过程，导致中间的那次对勾就没有显示出来就重新开始显示新的状态，从而task图标一直显示Failure，在Task面板中就看不见曾经收到事件，如果task图标每帧立刻更新应该可以看见状态的变化。因此不能完全依赖task图标显示的状态确定bt的执行，或者被不正确的图标状态显示迷惑。最严格的办法就是日志，可以在Behavior面板中选择LogTaskChanges查看task状态的改变；或者在Inspector中监控有用的变量，例如在Task求值成功时设置某个变量，如果这个变量确实被设置了，说明task确实求值成功了。
重载函数通过参数数目和参数类型确定唯一的函数签名，对于模板函数来说，参数的类型通过模板参数控制，因此模板参数就是函数签名的一部分。Func<T>不同的模板参数就是完全不同的函数，这里没有类型的继承关系，因为匹配的是函数签名（字符串），Func<A>与Func<B>就是完全不同的两个函数，即使B是A的子类，Func<B>的引用不能赋给Func<A>。这对模板类型同样有效，List<B>的引用不能赋给List<A>，因为List<B>会在内部生成唯一的类型签名List_B，List<A>会在内部生产唯一的类型签名List_A，而List_B与List_A没有继承关系。
BD事件系统匹配事件不仅包括事件名，还包括事件参数个数和类型，相当于有事件名／事件类型／事件参数构成唯一的事件签名，behaviorTree.SendEvent<GameObject>(“InAttack”, gameObject)就不能被behaviorTree.RegisterEvent<object>(“InAttack”, obj => {…})注册的事件回调接收到，因为事件参数类型不同，一个是GameObject，一个是object。
HasReceivedEvent内部注册使用的是object作为事件参数类型，因此如果使用BD内置的HasReceivedEvent，需要发送事件时也指定object作为SendEvent的模板参数，否则这个task收不到事件。
SendEvent最多支持3个参数，Variables面板中创建的变量类型Object指的是C#的object，而不是UnityEngine.Object

BD SharedVariable好像可以把object类型转换为合适的Shared类型，如SharedGameObject
SharedVariable sv;
sv.SetValue((object)gameObject)；
sv在Inspector面板中可以选择Variables面板中创建的GameObject变量，SetValue会判断并进行类型转换。但是如果转换失败，类型不匹配，也不会报错，而是不进行赋值。不要使用trikcy的方式，显胜于隐。

HasReceivedEvent每次收到事件后只返回一次Success，之后立刻重置并返回Failue。

Task脚本中应尽可能少出现特定组件（例如PlayerCtrl／MonsterCtrl），因为这样就把task绑定在这种类型的gameobject上，除非这种组件对游戏来说是通用的，就像Unity内置的各种组件，应尽可能使用使用通用的组件
保证task的可重用性。对于和gameobject相关的数据，都应该以参数暴露在task的inspector中，对不同的gameobject可以使用相同的task，配置不同的参数即可。不要绑定具体的component到一个task上，不要在其中实现AI，而是转移到Task中。通过BD事件／Task参数／external tree实现最大程度复用

只要有可能就在BD中实现全部功能，一旦和具体component耦合，可复用性就会迅速下降；实现一个功能之前先考虑是否在BD中能实现。如果必须要component和BT交互否则就无法实现，通过event来通讯。只有一个目标：解耦

Task中声明的shared variable只是说可以使用Task所在tree中创建的variable，不是在tree中创建对应名字的变量。只有tree可以创建真正存在的变量，task中的shared variable只是说可以引用tree中创建的相同类型的变量，并在task中以什么名字被使用，可以在Inspector中配置task使用Variable面板中创建的哪个变量
Task代码中的shared variable只是引用，tree的variable面板中创建的变量才是实体，inspector中配置task的引用指向哪个实体。variable创建的变量是树的一部分，即使作为外部树资源，被加载到其他树中，这些变量仍然存在于加载之后到子树中，只不过和加载它的树的共享变量同名的会被覆盖

行为树的本质就是if／else的可视化编辑，因为游戏AI的本质就是大量的if／else分支
所有可以用于if／else的编程原则都可以用在行为树上
当你对行为树的设计感到迷惑时，就去立即对应if／else分支实现
复杂的if／else分支流程有两种实现风格：扁平化与嵌套。就先tree一样，一组相同节点不同结构的tree，按照先序遍历能得到相同的遍历结果，而遍历的顺序就是优先级的顺序，亦即这些tree对于AI来说是等价的。只不过有的tree高而陡峭，有的tree低而扁平（优先级既可以用左右顺序实现，也可以用高低顺序实现）。按照编程原则，应该尽可能使用扁平结构。

设计AI，先找AI最好优先级的任务是什么，如果最好优先级任务不能做，次高优先级的任务是什么，一次类推。
因此通常用BT设计的AI就是一个select root task，下面挂载一组预先设计好的AI task，按照优先级从左到右排列成兄弟节点（扁平化），每个task里面是关于如何实现这个task的细节。每次对tree求值，select总是从子节点中选择优先级最高的可执行task。每个AI task的最终叶节点是真正执行任务的地方，它将一直运行Running，直到运行完毕，返回成功或失败。

每次行为树的求值都是为AI找一件可以做到事情，并把这件事情做完，因为下一次求值是要为AI找一件新的事情去做。因此，每一次求值，最后的叶子结点需要把事情做完再返回，即一直running，直到做完后再返回Success／Failure。例如追击目标需要彻底追上（Success）或者目标逃离（Failure）在返回，如果仍然在追击过程中，只能返回running。对应的if／else程序就是，AI逻辑经过层层if／else分支筛选进入到最终叶子节点分支，需要执行一个while循环，去执行这个节点要做的事情，直到事情做完（成功或失败），while退出。

例如在编写一个正则表达式解析的程序，有两种方式：
一种方式是在一个大的while循环中，只使用if／else，通过状态变量控制每次while循环总是落入相同的if／else分支做同一件事情，解析正则表达式的同一个部分，直到做完为止；另一种方式是在一个大的while循环中，不仅嵌入大量if／else，在if／else的最内层，还有while循环控制直到做完这件事，即解析完当前正在表达式的子项，再返回大的while循环去解析下一个子项，这相当于用代码控制状态（协程），而不是用额外的变量控制状态（状态机）
这两种方式就对应行为树的两种实现：
只使用if/else的实现，就是每次tick都求值整个tree，通过状态变量控制流程落入同一个叶节点去做同一件事，直到事情作为位置，这种实现每个task只有两种返回Success/Failure，没有Running
不仅使用if/else，还是用while的实现，如果当前处于内部的while，每次tick只执行这个循环，直到执行完毕，再从头求值整个tree。这种实现每个task除了返回Success／Failure，在内部循环中还返回Running，使得下一次tick直接从这里开始

不带内部循环的tree实现更简单，但是性能有失，另外与编程一样，通过状态变量控制唯一的最外侧循环每次去做同一个任务不够实用一个内部while去完成这个任务更直观（用代码表示状态->协程）
带内部while循环的tree实现是前者的超类，因为它能做出前者一样的事情（不使用内部循环就好了，即task不返回Running，只有Success／Failure）。但是后者能通过内部while进行优化，而且更直观所以更高级。唯一有所限制的是，不带内部while循环的方式自动能实现条件中断，即更高层if／else条件发生变化，每次tick会自动中断当前的任务转而执行更高优先级的任务。带内部while的实现方式则需要conditonal abort方式使得更优先级条件发生变化时，可以中断当前while循环。可以认为后者的while循环（Active Task）的判断条件包含所有更高优先级的条件，这样其每次求值都会将更高优先级的条件求值一次。每个conditonal abortTask都会成为比它优先级低的Active Task的while循环判断条件之一。

AI行为设计的核心就在于一个概念：优先级
优先级也是设计行为树的基本原则
游戏AI行为的就是由一组具有优先级的task组成。AI总是倾向先做高优先级的事情，只要高优先级的条件不满足，才选择次优先级的事情去做，依次类推。如果当前低优先级的任务正在执行，高优先级条件满足了，则立刻停止当前任务转而去做高优先级任务。只要按照这个原则去设计行为树就可以了。

BD行为树最佳使用方式就是叶子结点做一件事直到做完在返回（Running），即直观又高效，即Active Task总是返回Running，直到完成，返回Success／Failure结束。

每次tick求值整个tree是行为树最正确的办法，但是因为带有while循环的tree性能更好，更直观，所以更倾向使用后者。为了实现高优先级的条件打断Active Task，每次将所有高优先级的条件求值一次才是最正确的方式。即将全部的composites task都设为both，这样就和没有while的tree实现完全一样，高优先级条件总是能打断低优先级的任务。除非确定某些composites task确实不需要打断低优先级的任务，可以设置其不中断。总之越多的composites task设置为abort，越接近正确的求值。所以将任意composites task设置为abort，总是接近正确的求值。所以BD中加载external tree时，挂载的root task（reference task）总是设置为low priority，而没有自定义abort的选项，因为这更接近正确的求值，所以没有任何问题。对于self abort，因为是子树内部的abort类型，所以需要的话，在external tree内部设置，不需要在挂载的task处设置。

共享变量是BT的公共存储区域，无论作为序列化后的资源文件还是加载到内存的数据结构，无论是作为单独的行为树，还是作为其他树的external子树，这个存储区域都是和这个tree存储在一起的。但是当作为external tree加载到其他的tree中时，BD提供了覆盖external tree存储区域中共享变量的方式：
1 parent tree和external tree同名同类型的变量，parent的shared variable会覆盖external中的变量
2 如果parent中没有external tree中同名变量，则这个变量只存在于external tree的存储区域，并只被external中的所有task使用，相当于作用域为external tree的局部变量
3 在reference task的inspector面板中，可以在variables选项中选择覆盖子树的shared variable，设置相同的名字和类型，value字段可以hard code也可以选择当前tree中的同类型的shared variable。如果parent tree和external tree具有同名同类型变量，还在variables选项中设置了覆盖，则这个变量在parent tree中使用parent存储区域的变量值，而external tree中使用variables中设置的覆盖值

Behavior Tree组件面板中显示了和BD窗口中Behavior选项面板相同的设置，如果需要设置整个tree的options，可以直接在Component面板中设置，而不需要打开BT窗口。Component还展示了parent tree以及所有external tree所有的shared variable，这样就可以在Component面板中修改这些变量来测试AI树的行为。但是这里的external tree的变量并没有考虑variables选项中的覆盖，只显示了tree存储区域中的value以及同名变量的parent的value。

只有简单的事情才可能有完美的解决方案，复杂宏伟的事业没有完美可言，都是各种因素相互依赖影响，在各种势力之间达成尴尬的妥协，使事情得到完成
电影拍摄／巨著写作／游戏开发都是复杂宏大的工程，不要试图在每个细节上都寻找完美的解决方案，所有的因素都相互影响，最终每个方面都无法做到最好，但是这是能让整个系统运行起来的唯一的办法。
如果可能，自然使用更好更先进的技术，对每个细节寻找更佳的解决方案，但根本目的是让游戏得以完成运行起来，这是第一原则，为了达到这个目的，几乎不可避免对于每个方面步骤都要做出妥协，使用不是最优的解决方案，使各个系统之间得以以最低的努力完成兼容。使不同的系统以最低effort兼容以使整个系统运行起来是最大的技能，为此每个组成系统都要做出妥协，不以自己系统达到完美为原则，而是让其他系统最快兼容为原则，这几乎使得每个系统都不是完美的，但是这是使得整个系统良好运行起来的唯一办法。如果一个系统都试图达到自己最好的，就会给其他系统高度effort才能兼容之，如果每个子系统都如此，整个系统就无法构建起来。

构建宏大工程最根本原则和最高技能就是使构成其的各个子系统以最低effort兼容，不仅是以最快速度使系统运行起来，很多时候这是成功构建的唯一选择。为此，每个系统都要做出妥协是应有之义，每个系统都不能以自己完美为目标，而应该以让其他系统最快最低effort兼容为目标
不要总是想着扩展性，过早优化过度设计是万恶之源。很可能你的提前设计都是无用功。更可能的是，对于每个子模块，只以最低最简单的方式实现可能已经是最终能完成整个系统的最高标准了

如果仔细观察已经完成的各种宏大的工程（AAA游戏，游戏引擎，好莱坞大片，名著），内部无不充满着各种丑陋妥协，如果单独完成这个模块肯定不会像这样粗糙而是很精致，但这是将所有子系统兼容在一起完成整个系统做出的让步，即使以这种方式，可能已经是完成整个宏伟工程的最高标准了

构造行为树和编程的原则一样，尽可能将不同的功能分割为单一的external tree，通过组合external tree构成整个行为树，这样可以隔离每个功能，对其进行单独的开发和测试

Navmeshagent的启动和停止具有加速减速过程，当设置stop时，navmeshagent使用加速度进行减速，因此最终停止的位置可能超过set stop时所在的位置，例如行为树中通过triggerEnter设置navmeshagent stop，如果navmeshagnet移动太快，会发现agent停止的位置超过了碰撞发生的位置。解决办法是设置agent的acceleration为很大的值，这样agent就能很快减速

使用事件作为条件检测而不是每次轮训重新检测的一个问题是，has received event只触发一次
如果insightrange事件触发后，又触发了inattackrange，action就会迁移到attack，但是当player立刻attack range后，仍然处于sight range，但是因为insightrange不会重新出发，ai就会转移到patroll分支上去
就像每次tick求值整个tree总是最正确的一样，条件检测每次都重新检测总是最正确的
一种解决方案是实现一个in／out received event，in事件之后总是返回Success，直到out事件发生后返回Failure
另一种方案是使用BD内置的task组件拼装出一个这样的子树模块：设置一个shared bool变量保存状态，使用ReturnSuccess（总是返回Success）挂载has received event来检测事件，根据事件set／reset状态变量，但是忽略其返回状态

单独测试一个动作分支的external tree时，可以在最后添加几个可视／可听的action，确定tree执行完毕，但是在测试完成时记得删除它们

行为树本质上是可视化的if／else分支流程编辑器，行为树能做的事情代码都能做，但是对于编辑复杂的if／else分支程序，行为树更便捷，用代码暴力实现复杂的if／else分支程序将会十分笨拙而难于扩展，如果想使用代码实现一种方便的扩展分支程序的机制，最终不过是实现一个简陋的功能不全的行为树而已。
行为树和代码（task）都能实现if/else分支程序，因此整个完整的分支程序最终会部分流程在行为树中编辑，部分被包含在最终的task代码中，即整个分支程序，上面的部分被行为树覆盖，下面的部分被各种task覆盖。而行为树和task的边界没有明确的标准，即task的粒度。task过大，就会包含更多的if／else，而行为树控制的更少；task过小，则行为树就会变的更大。BD提供了相当对的内置的基本task，囊括了几乎全部组件，但是用这些基本组件组装出一个概念上独立的task仍然没有代码直接实现方便（包括选择合适的task，在task之间的通信，同时还会时行为树变大，每个task的求值都需要调用生命周期，性能上也没有在一个task中实现更好）。
行为树和代码实现都有各自的优劣势：
行为树可以方便的实现和快速调整复杂的分支程序，但是对于概念固定独立的动作，使用基本组件实现没有直接用代码实现方便；代码不适合编写大规模复杂的分支程序，但是对于较小的分支程序要比行为树快速高效。
因此需要结合行为树和代码的优势，使用行为树实现分支逻辑（基本上只会用到行为树的composites task），将叶子节点要执行的概念独立的动作在自定义task中实现（对各种Component的操作，transform／rigidbody／navmeshagent／animator／audiosource，以及一些简单的if／else逻辑）

行为树就像任何的高级工具一样，启动起来需要更高的边际成本，但是对于大规模的问题成本更低；代码作为低级的工具，实现一些简单的if／else分支逻辑要比行为树更快捷，成本更低，但是对更大规模的问题有心无力。就像是不同曲率的两条曲线，在相交之前，代码比行为树成本更低，相交之后，行为树成本更低。

用自定义task实现gameobject的独立动作另一个优势是，执行这个动作通常要改变不同组件的状态，但是当这个动作结束之后希望将改变的组件恢复到之前的状态，否则就会影响其他分支动作的执行（除非每个动作在开始时都将各种组件状态设置为合适的状态，但是这将要求每个分支动作都要做许多不必要的工作）。因为行为树具有conditional abort功能，如果使用basic组件实现独立动作，在这个动作子树被中断时，将无法恢复已经修改的组件状态，行为树就没有这种支持。但是如果用自定义task则能够实现，因为task在求值结束时会被调用OnEnd（即使因abort结束），可以在OnEnd中做清理恢复工作。

尽管BD提供的基本组件不适合用来实现真正的动作，但是其仍有很大的方便之处，就是用来做一些测试和原型的任务。BD就是一种可视化编程工具，和Bolt／PlayMaker一样，行为树包含了循环／条件分支，external tree可以作为认为是函数，shared variable可以用来通信，这是一个完整的编程语言，因此完全可以不写代码而只在行为树中实现全部功能。对于一些基本测试的需求，例如想要给一个rigidbody一个初始化的速度，来查看碰撞的细节，使用代码就需要写一个脚本，而里面只有一行代码：GetComponent<Rigidbody>().velocity = velocity。但是使用行为树，只需要给gameobject添加一个behavior tree组件，然后在编辑面板中添加一个SetVelocity Task，设置其值就可以了，不需要任何额外的脚本工作，非常便利。还有，在测试行为树的时候，可以在怀疑的地方添加一个可视／可听的task，作为调试输出的手段，在测试完成时删除就可以了。