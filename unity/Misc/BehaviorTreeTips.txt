哈夫曼树从一开始就模块化，因为任何功能模最终都要模块化，从一开始就模块化以避免延迟模块化带来的问题

可视化编程 框架化 所有的framework都是，虽然失去一部分灵活性，但是将绝大多数时间内使用的常用操作以标准化的形式简化固定，虽然每个操作简化一点，感觉比直接写没有简单的多少，但是项目工作量巨大，框架化简化的时间将是可观的，并且从心理上更能接受，因为对于每个操作都尽可能去除了不必要的部分，只保留你关心的，使得你更愿意去开发，任何事情去做的门槛／成本降低一点，去做的意愿和频率就越大，这就是框架化／可视化编程的价值。对于那些无法通过框架提供的操作，可以直接编写来实现，在框架与自定义实现之间建起桥梁，这样既使用了框架化的便利，又保证自定义实现所有需求。

Behavior tree，基于状态，而不是时刻，定时tick，但是不能依赖什么时候tick，就像update。一个update可能触发两次子树执行。
一个tree节点代表一个特定范围的动作抽象，节点层次越低，动作抽象越具体。叶结点action可以返回running，一直运行完成才返回，相应的，其每个层层的父节点／祖先节点也因此在一段时间内pending，知道整个节点子树运行完毕才想上返回，即当前动作得以保持。所以设计bt时，要记得一个动作全部限定在子树内执行完成，一直到完成才向上返回，不要依赖bt更新，在多次更新中使用自定义状态实现逻辑，这就落入最原始的while／if／else的形式了。状态机／bt在这方面是一样的，其内在机制已经为你保持了状态，你应该基于状态机／行为树更高的层次的抽象进行工作（基于状态／基于行为），而不是仍然使用底层的while／if／else的思维。
行为树的基本抽象就是行为。每个树的节点都是一个行为，一个行为有子行为构成，因此设计行为树时要给每个节点一个明确的定义，这个节点执行的是什么行为。遍历行为树，任意时刻只能在一个子树上，即任意时刻只执行一个行为，只有把当前行为（当前子树）执行完毕才向上回溯寻找其他行为执行，一个行为可以返回running运行任意长的时间，使当前行为和更高层的父行为／祖先行为同样pending相应的时间，即一个子树行为的遍历不一定在一个tick中执行完，甚至通常不是这样，而是在一定的时间之内才运行完，行为树内部设计会自动保存当前状态，使得下次tick仍然在当前子树上执行。
基于行为设计行为树，一旦落入某个子树，必须将整个子树执行完毕才返回，除非被conditional abort中断。
行为子树可以分开来开发测试，自底向上，每个子树完成时集成到更大的行为上，最终完成整个行为树
无论是编程还是任何事情，都要自底向上，逐步求精才能做成，断没有急于求成，否则不能成事。合抱之木生于毫末，九尺之台累于微土，千里之行始于足下

Behavior Tree 为逻辑建立起一个给予优先级的分支框架，所有的逻辑分割成一个一个小块，写成 tree 的叶节点。任何时刻，当前逻辑总是在某个叶节点上，在 OnUpdate 中更新，进而当前逻辑总是落在某个子树中。中间节点全部都是 conditional 节点，逻辑不会停在 conditional 节点里面，它们只是直到逻辑落到哪个子树里面，最终进入到某个叶节点。

因此 Behaviour Tree graph 的核心作用是组织逻辑分支（while-if-else），而不是 gameobject 如何执行每个动作。动作在 task 的 C# 脚本中定义。

Tree Graph 显式的是 while-if-else 逻辑，例如 object 进行攻击动作时，只会在 tree 只放置一个 attack action，从 Behavior tree 中时看不出来 object 如何执行一个动作，动作只能通过 task C# code 来定义。

Behavior tree 分为两个部分：

- 通过 tree 组织 while-if-else 分支，这里不必明确每个叶节点 task 的逻辑，例如一个 attack 节点，只是这个叶节点的抽象标签
- 通过 task C# 脚本定义 object 如何执行这个动作（OnStart，OnUpdate，OnEnd），例如 attack 脚本中定义播放哪个动画，何时发出攻击，给对方减少多少伤害等等

Behavior Designer（Movement Pack），Sensor Toolkit 等等组件说明，开发的精髓就是模块化，可重用，编写的每个功能都尽可能和具体要实现的功能通过隔离，通过参数，上层函数等中间层使用和具体场景无关的基础功能组合来完成具体功能。这就是函数式编程的精神，每个函数只完成最少的功能，通过函数之间不断组合，实现最终的功能。

Behavior Tree 本质就是 while-if-else 逻辑分支的可视化图形编辑器。编辑 Behavior Tree 和手动编写 while-if-else 是完全一样的，因此编辑 BT 时，就想手动编写逻辑分支是什么样的就可以了。之所以使用 BT，是因为：
1. 可以可视化快速编辑逻辑功能，可以快速实验迭代 AI 逻辑
2. 强制逻辑写成单个 task，task 只包含通用的 action 逻辑，通过参数具体化 task 在 BT 中，还有可以将 BT 保存为可重用的 External BT 作为其他 BT 的子树，同样可以使用参数具体化 External BT。这就强制以模块化和可重用的方式实现 AI 逻辑，而模块化和可重用是开发的精华

Unity 基础知识是游戏开发的根基，是极为重要的，不能完全依赖插件工具。只精通那些具有通用功能和目的的插件，不要花费精力到非通用工具上。使用通用的组件辅助，使用 Unity 基础知识实现想要的功能，这样既熟悉了这些通用目的工具，用熟悉了 Unity 基础知识。将那些通用目的插件列入基础知识行列。非通用目的工具难于定制，使用不频繁，因此难于记忆而且难于使用。

Behavior Tree 可以视为可视化协程 coroutine 编辑器。

任何时候 BT 树都在一个末端节点 task（action）中求值，所有 composite 节点只用于导航分支逻辑的，即每一帧都是一个 task 在 Update。

一个任务 task（action）跨越多个 frame 执行，而从代码上看却是在一个地方执行，即以同步代码片段执行异步程序，这正是 coroutine 的概念，这也是为什么使用 coroutine 异步风格编程能简化编程复杂性的原因。

游戏 AI 逻辑都是分为一个一个 task 的，task 在 code 中是一个逻辑单元，但执行时需要跨越多个 frame。这是 coroutine 最擅长的。在 FSM 中就是一个状态，状态在多个 frame 之间维持。BT 就可以看成是 coroutine 的可视化编辑器，每个 task 都是一个 coroutine， 每个 composite task 是组合 coroutine 的 coroutine。例如 sequence task：

async Task<bool> Sequence() {
    bool ret = false;
    ret = await ChildTask0();
    if (ret == false) {
        return false;
    }
    ret = await ChildTask1();
    if (ret == false) {
        return false;
    }
    // ...
    ret = await ChildTaskN();
    if (ret == false) {
        return false;
    }
    return true;
}

Behavior Designer Movement/Tactical/Formations pack 不够通用。对于复杂的 task，这些 pack 难于定制，对于简单的 task，直接使用 Unity 基础知识实现足够，不必花费很多精力记住这些 pack，而经常练习 Unity 基础知识是非常重要的，这些 pack 可以用于学习目的。

编程的精髓就是组合模块、可重用，而 BT 天生就是强制模块和组合的，因此尽可能使用 BT 实现所有 AI 逻辑。
